<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="label2.Text" xml:space="preserve">
    <value>Επιστήμη υπολογιστών ονομάζεται η θετική και εφαρμοσμένη επιστήμη η οποία ερευνά τα θεωρητικά θεμέλια και τη φύση των δομών δεδομένων, 
των αλγορίθμων και των υπολογισμών, από τη σκοπιά της σχεδίασης, της ανάπτυξης, της υλοποίησης, της διερεύνησης, της ανάλυσης και της προδιαγραφής
 τους[1][2][3][4][5][6]. Ασχολείται με τη συστηματική μελέτη της σκοπιμότητας, της δομής, της έκφρασης και του μηχανισμού των μεθοδικών διεργασιών
 (ή αλγορίθμων) που αποτελούν την επεξεργασία, την αποθήκευση, την επικοινωνία και την πρόσβαση στα δεδομένα. Ένας εναλλακτικός ορισμός της επιστήμης 
των υπολογιστών είναι η μελέτη της αυτοματοποίησης αλγοριθμικών διεργασιών που κλιμακώνονται. Ένας επιστήμονας υπολογιστών ειδικεύεται στη θεωρία
 της υπολογιστικής ισχύος και το σχεδιασμό των υπολογιστικών συστημάτων[7].H επιστήμη υπολογιστών ως διακριτή επιστήμη κάνει την εμφάνισή της τη
 δεκαετία του 1940, όταν κατασκευάστηκαν οι πρώτες υπολογιστικές μηχανές γενικού σκοπού και τέθηκαν τα θεωρητικά θεμέλια του υπολογισμού. Η δημιουργία 
των πρώτων ακαδημαϊκών τμημάτων έγινε τη δεκαετία του 1960[8], ενώ η διάθεση των προϊόντων της έρευνας της στην κοινωνία (τεχνολογία πληροφοριών 
και επικοινωνίας) άρχισε να λαμβάνει χώρα ευρέως μετά το 1970, με αποτέλεσμα σημαντικές κοινωνικές, οικονομικές και τεχνολογικές αλλαγές σε διεθνές 
επίπεδο[9].

Η επιστήμη υπολογιστών δεν πρέπει να συγχέεται με τη θεωρία πληροφορίας, ένα πεδίο των εφαρμοσμένων μαθηματικών. Επίσης, η ιδιότητα του επιστήμονα 
υπολογιστών δεν πρέπει να συγχέεται με την επαγγελματική ιδιότητα του προγραμματιστή, δηλαδή ατόμου βιοποριζόμενου από την ανάπτυξη λογισμικού 
υπολογιστών, εφόσον η επιστήμη υπολογιστών δεν συνίσταται στον ίδιο τον προγραμματισμό μα στην επιστημονική μελέτη των αλγορίθμων και της σχεδίασης, 
ανάλυσης και κατασκευής υλικού ή λογισμικού υπολογιστών και αποδοτικών, αυτοματοποιημένων υπολογιστικών υποδομών για τη μηχανική εκτέλεση
 αλγορίθμων[5][10][11]. Η επιστήμη υπολογιστών αξιοποιεί επομένως τον προγραμματισμό όχι ως αυτοσκοπό, μα ως ένα από τα βασικά εργαλεία της και από 
τα κύρια αντικείμενα μελέτης της[4]. Ωστόσο, είναι σύνηθες ένας επαγγελματίας προγραμματιστής να έχει σπουδάσει σε κάποιον βαθμό την επιστήμη
 υπολογιστών. Τέλος, η επιστήμη υπολογιστών δεν πρέπει να συγχέεται απλά με τις δεξιότητες χρήσης Η/Υ και έτοιμων πακέτων λογισμικού (π.χ. επεξεργαστών
 κειμένου κλπ.), αφού η απλή χρήση των υπολογιστών δεν έχει επιστημονικό χαρακτήρα και σκοπό.

Τα πεδία της επιστήμης υπολογιστών διακρίνονται σε μια ποικιλία θεωρητικών και πρακτικών κλάδων. Κάποια από τα πεδιά αυτά, όπως η θεωρία 
υπολογιστικής πολυπλοκότητας, που εξερευνά τις θεμελιώδεις ιδιότητες των υπολογιστικών και δυσεπίλυτων προβλημάτων, είναι πολύ αφηρημένα, ενώ τομείς
 όπως τα γραφικά υπολογιστών δίνουν έμφαση σε οπτικές εφαρμογές του πραγματικού κόσμου. Ακόμη σε άλλους τομείς επικεντρώνεται στις προκλήσεις των
 εφαρμογών υπολογισμού. Για παράδειγμα, η θεωρία γλωσσών προγραμματισμού θεωρεί διάφορες προσεγγίσεις για την περιγραφή των υπολογισμών, ενώ η
 μελέτη του προγραμματισμού ηλεκτρονικών υπολογιστών ερευνά διάφορες πτυχές της χρήσης της γλώσσας προγραμματισμού και τα πολύπλοκα συστήματα.
 Η αλληλεπίδραση ανθρώπου-υπολογιστή εξετάζει τις προκλήσεις στην κατασκευή των ηλεκτρονικών υπολογιστών, κάνοντας τους υπολογισμούς όσο το 
δυνατό πιο χρήσιμο, εύχρηστο, και καθολικά προσβάσιμο στους ανθρώπους.</value>
  </data>
</root>